use error::{Error,Result};
use cleaner::{Cleaner, French};

use std::fs::File;
use std::io::Read;
use std::env;
use std::path::Path;

use mustache;
use mustache::MapBuilder;
use zip::CompressionMethod;

// Numbering for a given chapter
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum Number {
    Unnumbered, // chapter is not numbered
    Default, // chapter follows books numbering, number is given automatically
    Specified(i32), //chapter number set to specified number
}
    
// Configuration of the book
pub struct Book {
    // Generic options
    pub numbering: bool, // turns on/off chapter numbering (individual chapters may still avoid it)
    pub autoclean: bool, 
    pub chapters: Vec<(Number, String)>,  // list of the markdown files to process
    pub lang: String,
    pub author: String,
    pub title: String,
    pub description: Option<String>,
    pub subject: Option<String>,
    pub cover: Option<String>,
    pub nb_char: char,
    pub zip_compression: CompressionMethod,
    pub numbering_template: String, // template for chapter numbering
}

impl Book {
    // Creates a new Book with default options
    pub fn new() -> Book {
        Book {
            numbering: true,
            autoclean: true,
            chapters: vec!(),
            lang: String::from("en"),
            author: String::from("Anonymous"),
            title: String::from("Untitled"),
            description: None,
            subject: None,
            cover: None,
            nb_char: 'â€¯',
            zip_compression: CompressionMethod::Stored,
            numbering_template: String::from("{{number}}. {{title}}"),
        }
    }

    /// Creates a new book from a file
    ///
    /// This method also changes the current directory to the one of this file
    pub fn new_from_file(filename: &str) -> Result<Book> {
        let path = Path::new(filename);
        let mut f = try!(File::open(&path).map_err(|_| Error::FileNotFound(String::from(filename))));

        // change current directory
        if let Some(parent) = path.parent() {
            if !env::set_current_dir(&parent).is_ok() {
                return Err(Error::ConfigParser("could not change current directory to the one of the config file",
                                               format!("{}", parent.display())));
            }
        }

        
        let mut s = String::new();

        try!(f.read_to_string(&mut s).map_err(|_| Error::ConfigParser("file contains invalid UTF-8, could not parse it",
                                                                      String::from(filename))));
        let mut book = Book::new();
        try!(book.set_from_config(&s));
        Ok(book)
    }

    /// Returns a MapBuilder, to be used (and completed) for templating
    pub fn get_mapbuilder(&self) -> MapBuilder {
        MapBuilder::new()
            .insert_str("author", self.author.clone())
            .insert_str("title", self.title.clone())
            .insert_str("lang", self.lang.clone())
    }

    /// Return a Box<Cleaner> corresponding to the appropriate cleaning method, or None
    pub fn get_cleaner(&self) -> Option<Box<Cleaner>> {
        if self.autoclean {
            let lang = self.lang.to_lowercase();
            if lang.starts_with("fr") {
                Some(Box::new(French::new(self.nb_char)))
            } else {
                Some(Box::new(()))
            }
        } else {
            None
        }
    }

    /// Returns the string corresponding to a number, title, and the numbering template
    pub fn get_header(&self, n: i32, title: &str) -> Result<String> {
        let template = mustache::compile_str(&self.numbering_template);
        let data = MapBuilder::new()
            .insert_str("title", String::from(title))
            .insert_str("number", format!("{}", n))
            .build();
        let mut res:Vec<u8> = vec!();
        template.render_data(&mut res, &data);
        match String::from_utf8(res) {
            Err(_) => Err(Error::Render("header generated by mustache was not valid utf-8")),
            Ok(res) => Ok(res)
        }
    }

    /// Sets options according to configuration file
    ///
    /// A line with "option: value" sets the option to value
    /// + chapter_name.md adds the (default numbered) chapter
    /// - chapter_name.md adds the (unnumbered) chapter
    /// 3. chapter_name.md adds the (custom numbered) chapter
    pub fn set_from_config(&mut self, s: &str) -> Result<()> {
        fn get_char(s: &str) -> Result<char> {
            let words: Vec<_> = s.trim().split('\'').collect();
            if words.len() != 3 {
                return Err(Error::ConfigParser("could not parse char", String::from(s)));
            }
            let chars: Vec<_> = words[1].chars().collect();
            if chars.len() != 1 {
                return Err(Error::ConfigParser("could not parse char", String::from(s)));
            }
            Ok(chars[0])
        }
        
        fn get_filename(s: &str) -> Result<&str> {
            let words:Vec<&str> = (&s[1..]).split_whitespace().collect();
            if words.len() > 1 {
                return Err(Error::ConfigParser("chapter filenames must not contain whitespace", String::from(s)));
            } else if words.len() < 1 {
                return Err(Error::ConfigParser("no chapter name specified", String::from(s)));
            }
            Ok(words[0])
        }
        
        for line in s.lines() {
            let line = line.trim();
            let bool_error = |_| Error::ConfigParser("could not parse bool", String::from(line));
            if line.is_empty() || line.starts_with('#') {
                continue;
            }
            if line.starts_with('-') {
                //unnumbered chapter
                let file = try!(get_filename(line));
                self.add_chapter(Number::Unnumbered, String::from(file));
            } else if line.starts_with('+') {
                //nunmbered chapter
                let file = try!(get_filename(line));
                self.add_chapter(Number::Default, String::from(file));
            } else if line.starts_with(|c: char| c.is_digit(10)) {
                // chapter with specific number
                let parts:Vec<_> = line.splitn(2, |c: char| c == '.' || c == ':' || c == '+').collect();
                if parts.len() != 2 {
                    return Err(Error::ConfigParser("ill-formatted line specifying chapter number", String::from(line)));
                } else {
                    let file = try!(get_filename(parts[1]));
                    let number = try!(parts[0].parse::<i32>().map_err(|_| Error::ConfigParser("Error parsing integer", String::from(line))));
                    self.add_chapter(Number::Specified(number), String::from(file));
                }
            } else {
                // standard case: "option: value"
                let parts:Vec<_> = line.splitn(2, ':').collect();
                if parts.len() != 2 {
                    return Err(Error::ConfigParser("option setting must be of the form option: value", String::from(line)));
                }
                let option = parts[0].trim();
                let value = parts[1].trim();
                match option {
                    "nb-char" | "nb_char" => self.set_nb_char(try!(get_char(value))),
                    "zip-compression" | "zip_compression" => self.zip_compression = match value {
                        "stored" => CompressionMethod::Stored,
                        "deflated" => CompressionMethod::Deflated,
                        "bzip2" => CompressionMethod::Bzip2,
                        _ => return Err(Error::ConfigParser("unrecognized compression method", String::from(value))),
                    },
                    "numbering-template" | "numbering_template" => self.numbering_template = String::from(value),
                    "numbering" => self.set_numbering(try!(value.parse::<bool>().map_err(bool_error))),
                    "autoclean" => self.set_autoclean(try!(value.parse::<bool>().map_err(bool_error))),
                    "author" => self.set_author(String::from(value)),
                    "title" => self.set_title(String::from(value)),
                    "cover" => self.set_cover(Some(String::from(value))),
                    "lang" => self.set_lang(String::from(value)),
                    "description" => self.description = Some(String::from(value)),
                    "subject" => self.subject = Some(String::from(value)),
                    _ => return Err(Error::ConfigParser("unrecognized option", String::from(line))),
                }
            }
        }

        Ok(())
    }

    /// Sets non-breaking character
    ///
    /// Currently only used if autoclean = true and lang = fr
    pub fn set_nb_char(&mut self, nb_char: char) {
        self.nb_char = nb_char;
    }

    /// Sets numbering of chapters
    ///
    /// false: no chapter is numbered
    /// true: chapters are numbered, expect the ones that opt out of it
    ///
    /// default: true
    pub fn set_numbering(&mut self, numbering: bool) {
        self.numbering = numbering;
    }

    /// Sets lang of a book
    ///
    /// Should be a standard code: En, Fr, ...
    ///
    /// Default: en
    pub fn set_lang(&mut self, lang: String) {
        self.lang = lang;
    }

    /// Sets author of a book
    ///
    /// A single string for full name
    ///
    /// Default: Anonymous
    pub fn set_author(&mut self, author: String) {
        self.author = author;
    }

    /// Sets title of a book
    ///
    /// Default: Untitled
    pub fn set_title(&mut self, title: String) {
        self.title = title;
    }

    /// Sets the cover for the book
    ///
    /// Specifies the name (and path!) of a file, e.g. "cover.png"
    ///
    /// Default: None
    pub fn set_cover(&mut self, cover: Option<String>) {
        self.cover = cover;
    }

    /// Sets whether cleaning of input markdown is activated
    ///
    /// Default: true
    ///
    /// The cleaning is dependend on the language. By default, it
    /// only removes multiple following spaces, so it should have no effect
    /// on generated result (expect for the source files). But in french,
    /// tries to 'intelligently' replaces spaces with non-breaking ones when
    /// in front of appopriacte characters ('?', '!', ':' and so on).
    pub fn set_autoclean(&mut self, autoclean: bool) {
        self.autoclean = autoclean;
    }

    /// Adds a chapter to the book and its number scheme
    ///
    /// Number: either Default, Unnumbered or Specified(number)
    /// File: location of the file for this chapter
    pub fn add_chapter(&mut self, number: Number, file: String) {
        self.chapters.push((number, file));
    }
}
